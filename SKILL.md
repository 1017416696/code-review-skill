---
name: code-review
description: 自动化代码审查技能，用于检查 Git 提交的代码变更。当用户请求审查代码、检查 PR、code review、review changes、review [hash] 或分析代码质量时触发此技能。审查完成后，用户可通过输入问题序号（如 "1"、"1,3,5"、"fix 1-3"）自动修复对应问题。
---

# Code Review

审查 Git 提交的代码变更，检查代码质量问题并生成简洁报告。

## 触发场景

### 审查代码
- `review` / `审查代码` / `code review`
- `review abc1234`（指定提交）
- `review abc1234..def5678`（多个连续提交）

### 修复问题（审查完成后）
- `1` / `fix 1` - 修复问题 1
- `1,3,5` / `fix 1,3,5` - 修复多个问题
- `1-3` / `fix 1-3` - 修复问题 1 到 3
- `fix all` / `fix critical` - 修复所有必须修复的问题
- `fix all issues` - 修复所有问题

### 提交修复（修复完成后）
- `0` - 提交本次修复修改的文件（自动生成提交信息）

## 审查流程

### 第一步：解析输入，确定审查范围

根据用户输入确定提交范围：

| 输入 | 审查范围 | Git 命令 |
|------|----------|----------|
| 无参数 | 最近一次提交 | `git show HEAD --stat` |
| `abc1234` | 指定的单个提交 | `git show abc1234 --stat` |
| `abc1234..def5678` | 从 abc1234 到 def5678 的所有提交 | `git log abc1234..def5678 --oneline` |

### 第二步：获取代码变更

**单个提交：**
```bash
git show <commit-hash> --format="%H%n%s%n%b" --stat
git show <commit-hash> --format="" -- .
```

**多个提交：**
```bash
# 获取提交列表（从旧到新，包含起始提交）
# 注意：git log A..B 不包含 A，需要使用 A~1..B 来包含 A
git log '<start>~1..<end>' --oneline --reverse

# 获取整体 diff（从 start 的父提交到 end，这样 diff 包含 start 的变更）
git diff '<start>~1..<end>'
```

> **注意**：
> - 用户输入 `abc1234..def5678` 表示要审查从 abc1234 到 def5678 的所有提交（包含两端）
> - 由于 `git log A..B` 语法不包含 A，实际执行时需要使用 `A~1..B` 来包含起始提交
> - 使用 `~1` 而非 `^`，因为 `^` 在 zsh 中是特殊字符需要转义
> - 多个提交时，按从旧到新的顺序展示提交列表，但只审查最终状态的代码变更

### 第三步：分析代码变更

1. 读取 [STANDARDS.md](STANDARDS.md) 获取审查规则
2. 根据变更文件的类型，应用对应的语言规则
3. 逐条检查是否违反规则
4. **代码风格一致性检查**：
   - 读取变更文件所在目录的 3-5 个现有文件
   - 对比代码风格（缩进、命名、导入顺序、注释风格等）
   - 如发现明显不一致，归入"建议改进"

### 第四步：生成审查报告

**单个提交报告格式：**

```markdown
# Code Review: <short-hash>

## 📊 变更概览
- **提交信息**: <commit message>
- **文件数量**: X 个文件
- **变更行数**: +X / -Y

## 🔴 必须修复

1. [问题类型] - `文件名:行号`
   问题描述及修复建议
   [如可自动修复，提供修复后的代码示例]

2. [问题类型] - `文件名:行号`
   问题描述及修复建议

## ⚠️ 建议改进

1. [问题类型] - `文件名:行号`
   问题描述及改进建议
   [如可自动修复，提供修复后的代码示例]

2. [问题类型] - `文件名:行号`
   问题描述及改进建议

## ✅ 总结
- 必须修复: X 个
- 建议改进: Y 个

---
💡 **提示**: 输入问题序号（如 `1` 或 `1,3,5` 或 `1-3`）可自动修复对应问题
```

**多个提交报告格式：**

```markdown
# Code Review: <start-hash>..<end-hash>

## 📊 变更概览
- **提交范围**: X 个提交（从旧到新排列）
- **文件数量**: Y 个文件
- **变更行数**: +A / -B

## 📝 提交列表（从旧到新）
1. `abc1234` - feat: add address validation
2. `bcd2345` - fix: handle null case
3. `def5678` - refactor: extract common method

## 🔴 必须修复
...

## ⚠️ 建议改进
...

## ✅ 总结
...
```

**无问题时：**

```markdown
# Code Review: <hash>

## 📊 变更概览
...

✅ 审查通过，未发现问题
```

### 第五步：交互式修复（可选）

当审查报告生成后，如果发现问题，等待用户输入：

**用户输入格式：**
- 单个问题：`1` 或 `fix 1`
- 多个问题：`1,3,5` 或 `fix 1,3,5`
- 范围：`1-3` 或 `fix 1-3`
- 修复所有必须修复：`fix all` 或 `fix critical`
- 修复所有问题：`fix all issues`

**修复流程：**

1. **解析用户输入**
   - 识别序号格式（单个、多个、范围）
   - 确定要修复的问题列表
   - 如果输入 `fix all`，修复所有"必须修复"的问题
   - 如果输入 `fix all issues`，修复所有问题

2. **逐个应用修复**
   - 读取对应文件
   - 应用修复建议（使用 search_replace 工具）
   - 如果问题无法自动修复，跳过并提示用户
   - 显示每个问题的修复状态

3. **修复完成提示**
   ```markdown
   ✅ 修复完成
   
   已修复：
   - 问题 1: [问题类型] - `文件名:行号` ✅
   - 问题 3: [问题类型] - `文件名:行号` ✅
   
   无法自动修复（需人工处理）：
   - 问题 5: [问题类型] - `文件名:行号` ⚠️
     原因: [说明为什么无法自动修复]
   
   请检查修复结果，确认无误后可提交代码。
   💡 输入 `0` 可提交本次修复的文件
   ```

**修复示例：**

用户输入：`1,3`
```
正在修复问题 1, 3...

✅ 问题 1: 魔法数字 - `AddressService.java:45`
   已将 `100` 替换为常量 `MAX_ADDRESS_COUNT`

✅ 问题 3: 调试日志 - `UserController.java:78`
   已删除 `System.out.println` 语句

修复完成！请检查代码确认无误。
```

**注意事项：**
- 如果问题无法自动修复（需要人工判断或上下文不足），明确告知用户原因
- 修复后提示用户检查，避免误修复
- 每个问题修复前，先确认文件存在且行号有效
- 如果修复失败，回滚更改并提示用户

### 第六步：快速提交（可选）

用户输入 `0` 后，自动执行以下操作：

1. **获取修复文件列表**
   - 收集本次修复过程中修改的所有文件路径

2. **分析实际修改内容**
   ```bash
   # 获取本次修改的 diff
   git diff <修复的文件列表>
   ```

3. **根据 diff 内容动态生成提交信息**
   - 分析 `git diff` 输出，理解实际修改了什么
   - 根据修改内容生成简洁、准确的提交信息
   - 遵循 Conventional Commits 格式

4. **执行 git 命令**
   ```bash
   git add <修复的文件列表>
   git commit -m "<根据 diff 动态生成的提交信息>"
   ```

5. **显示提交结果**
   ```markdown
   ✅ 已提交
   
   提交信息: <根据实际修改内容生成>
   修改文件: <文件列表>
   ```

**提交信息生成原则：**
- 通过 `git diff` 分析实际代码变更
- 提取关键修改点（如：添加常量、删除日志、提取方法等）
- 生成简洁准确的描述，而非固定模板

## 问题严重程度

| 级别 | 标识 | 说明 | 示例 |
|------|------|------|------|
| 必须修复 | 🔴 | 存在 bug、安全漏洞或严重问题 | 未处理的异常、硬编码密钥 |
| 建议改进 | ⚠️ | 影响代码质量或可维护性 | 魔法数字、重复代码、命名不规范 |

## 使用示例

### 完整流程示例

**步骤 1：审查代码**
```
用户: review abc1234
AI: [生成审查报告，列出问题 1-5]
```

**步骤 2：选择修复**
```
用户: 1,3
AI: [自动修复问题 1 和 3，显示修复结果]
```

**步骤 3：确认修复**
```
用户: 检查一下修复结果
AI: [展示修复后的代码片段，确认无误]
```

### 快速修复示例

```
用户: review
AI: [审查报告显示 3 个必须修复的问题]

用户: fix all
AI: [自动修复所有必须修复的问题]
```

### 修复并提交示例

```
用户: review abc1234
AI: [审查报告]
    1. 魔法数字 - AddressService.java:45
    2. 调试日志 - UserController.java:78

用户: 1,2
AI: ✅ 修复完成
    - 问题 1: 魔法数字 - AddressService.java:45 ✅
    - 问题 2: 调试日志 - UserController.java:78 ✅
    💡 输入 `0` 可提交本次修复的文件

用户: 0
AI: [执行 git diff 分析修改内容]
    ✅ 已提交
    提交信息: fix: add MAX_ADDRESS_COUNT constant, remove debug println
    修改文件: AddressService.java, UserController.java
```

> 提交信息通过 `git diff` 分析实际代码变更后动态生成，描述真实的修改内容。

## 审查规则

详见 [STANDARDS.md](STANDARDS.md)
